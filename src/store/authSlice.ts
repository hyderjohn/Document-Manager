import { createSlice, createAsyncThunk, PayloadAction } from "@reduxjs/toolkit";
import { mockAuthService, User } from "../services/authService";
import { LoginFormData } from "../pages/auth/Login";
import { RegisterFormData } from "../pages/auth/Register";

/**
 * Defines the shape of the authentication state managed by Redux.
 */
interface AuthState {
  user: User | null;       // Current user data, or null if logged out
  token: string | null;    // Auth token (JWT), or null
  status: "idle" | "loading" | "succeeded" | "failed"; // Status of async login/register ops
  error: string | null;    // Error message from failed operations
}

/** Initial state when the app loads */
const initialState: AuthState = {
  user: null,
  token: null,
  status: "idle",
  error: null,
};

/**
 * Thunk action: Handles user login via the auth service.
 */
export const loginUser = createAsyncThunk(
  "auth/loginUser", // Action type used internally by Redux Toolkit
  async (credentials: LoginFormData, { rejectWithValue }) => {
    try {
      // Replace with actual service call when backend is ready
      const response = await mockAuthService.login(credentials.email, credentials.password);
      return response; // Fulfilled action payload
    } catch (error) {
      // Return error message as rejected action payload
      return rejectWithValue((error as Error).message || "Login failed");
    }
  }
);

/**
 * Thunk action: Handles user registration via the auth service.
 */
export const registerUser = createAsyncThunk(
  "auth/registerUser",
  async (credentials: RegisterFormData, { rejectWithValue }) => {
    try {
      // Replace with actual service call
      const response = await mockAuthService.register(credentials.email, credentials.password);
      return response;
    } catch (error) {
      return rejectWithValue((error as Error).message || "Registration failed");
    }
  }
);

/**
 * Auth slice containing reducers and async action handlers.
 */
const authSlice = createSlice({
  name: "auth",
  initialState,
  // Reducers for synchronous state updates
  reducers: {
    /** Logs the user out by resetting state. */
    logout: (state) => {
      state.user = null;
      state.token = null;
      state.status = "idle";
      state.error = null;
      // Consider clearing token from localStorage/sessionStorage here too
    },
    /** Clears any existing authentication error message. */
    clearAuthError: (state) => {
      state.error = null;
    }
  },
  // Handlers for the async thunks (loginUser, registerUser)
  extraReducers: (builder) => {
    builder
      // Login states
      .addCase(loginUser.pending, (state) => {
        state.status = "loading";
        state.error = null;
      })
      .addCase(loginUser.fulfilled, (state, action: PayloadAction<{ user: User; token: string }>) => {
        state.status = "succeeded";
        state.user = action.payload.user;
        state.token = action.payload.token;
        // Consider storing token in localStorage/sessionStorage for persistence
      })
      .addCase(loginUser.rejected, (state, action) => {
        state.status = "failed";
        state.error = action.payload as string;
        state.user = null;
        state.token = null;
      })
      // Register states
      .addCase(registerUser.pending, (state) => {
        state.status = "loading";
        state.error = null;
      })
      .addCase(registerUser.fulfilled, (state, action: PayloadAction<{ user: User; token: string }>) => {
        state.status = "succeeded";
        state.user = action.payload.user;
        state.token = action.payload.token;
        // Consider storing token
      })
      .addCase(registerUser.rejected, (state, action) => {
        state.status = "failed";
        state.error = action.payload as string;
        state.user = null;
        state.token = null;
      });
  },
});

// Export synchronous actions generated by createSlice
export const { logout, clearAuthError } = authSlice.actions;

// Export the reducer to be included in the store
export default authSlice.reducer;
